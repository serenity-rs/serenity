<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A macro that transforms `async` functions (and closures) into plain functions, whose return type is a boxed `Future`."><title>hook in command_attr - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="command_attr" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0-nightly (f21554f7f 2024-06-08)" data-channel="nightly" data-search-js="search-9d4fa2dd5e5a7e17.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc attr"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../command_attr/index.html">command_attr</a><span class="version">0.5.2</span></h2></div><div class="sidebar-elems"></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Attribute Macro <a href="index.html">command_attr</a>::<wbr><a class="attr" href="#">hook</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/command_attr/lib.rs.html#916-958">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>#[hook]</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A macro that transforms <code>async</code> functions (and closures) into plain functions, whose return
type is a boxed <a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a>.</p>
<h2 id="transformation"><a class="doc-anchor" href="#transformation">§</a>Transformation</h2>
<p>The macro transforms an <code>async</code> function, which may look like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">async fn </span>foo(n: i32) -&gt; i32 {
    n + <span class="number">4
</span>}</code></pre></div>
<p>into this (some details omitted):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::future::Future;
<span class="kw">use </span>std::pin::Pin;

<span class="kw">fn </span>foo(n: i32) -&gt; Pin&lt;Box&lt;<span class="kw">dyn </span>std::future::Future&lt;Output = i32&gt;&gt;&gt; {
    Box::pin(<span class="kw">async move </span>{ n + <span class="number">4 </span>})
}</code></pre></div>
<p>This transformation also applies to closures, which are converted more simply. For instance,
this closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">async move </span>|x: i32| x * <span class="number">2 </span>+ <span class="number">4</span></code></pre></div>
<p>is changed to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>|x: i32| Box::pin(<span class="kw">async move </span>{ x * <span class="number">2 </span>+ <span class="number">4 </span>})</code></pre></div>
<h3 id="how-references-are-handled"><a class="doc-anchor" href="#how-references-are-handled">§</a>How references are handled</h3>
<p>When a function contains references, their lifetimes are constrained to the returned
<a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a>. If the above <code>foo</code> function had <code>&amp;i32</code> as a parameter, the transformation would be
instead this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::future::Future;
<span class="kw">use </span>std::pin::Pin;

<span class="kw">fn </span>foo&lt;<span class="lifetime">'fut</span>&gt;(n: <span class="kw-2">&amp;</span><span class="lifetime">'fut </span>i32) -&gt; Pin&lt;Box&lt;<span class="kw">dyn </span>std::future::Future&lt;Output = i32&gt; + <span class="lifetime">'fut</span>&gt;&gt; {
    Box::pin(<span class="kw">async move </span>{ <span class="kw-2">*</span>n + <span class="number">4 </span>})
}</code></pre></div>
<p>Explicitly specifying lifetimes (in the parameters or in the return type) or complex usage of
lifetimes (e.g. <code>'a: 'b</code>) is not supported.</p>
<h2 id="necessity-for-the-macro"><a class="doc-anchor" href="#necessity-for-the-macro">§</a>Necessity for the macro</h2>
<p>The macro performs the transformation to permit the framework to store and invoke the functions.</p>
<p>Functions marked with the <code>async</code> keyword will wrap their return type with the <a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a>
trait, which a state-machine generated by the compiler for the function will implement. This
complicates matters for the framework, as <a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a> is a trait. Depending on a type that
implements a trait is done with two methods in Rust:</p>
<ol>
<li>static dispatch - generics</li>
<li>dynamic dispatch - trait objects</li>
</ol>
<p>First method is infeasible for the framework. Typically, the framework will contain a plethora
of different commands that will be stored in a single list. And due to the nature of generics,
generic types can only resolve to a single concrete type. If commands had a generic type for
their function’s return type, the framework would be unable to store commands, as only a single
<a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a> type from one of the commands would get resolved, preventing other commands from
being stored.</p>
<p>Second method involves heap allocations, but is the only working solution. If a trait is
object-safe (which <a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a> is), the compiler can generate a table of function pointers
(a vtable) that correspond to certain implementations of the trait. This allows to decide which
implementation to use at runtime. Thus, we can use the interface for the <a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a> trait, and
avoid depending on the underlying value (such as its size). To opt-in to dynamic dispatch,
trait objects must be used with a pointer, like references (<code>&amp;</code> and <code>&amp;mut</code>) or <code>Box</code>. The
latter is what’s used by the macro, as the ownership of the value (the state-machine) must be
given to the caller, the framework in this case.</p>
<p>The macro exists to retain the normal syntax of <code>async</code> functions (and closures), while
granting the user the ability to pass those functions to the framework, like command functions
and hooks (<code>before</code>, <code>after</code>, <code>on_dispatch_error</code>, etc.).</p>
<h2 id="notes"><a class="doc-anchor" href="#notes">§</a>Notes</h2>
<p>If applying the macro on an <code>async</code> closure, you will need to enable the <code>async_closure</code>
feature. Inputs to procedural macro attributes must be valid Rust code, and <code>async</code> closures
are not stable yet.</p>
</div></details></section></div></main></body></html>